"""
test_db_tasks.py

В этом файле демонстрируется решение 9 заданий:
- 3 задания по пагинации,
- 3 задания по фильтрации,
- 3 задания по сортировке.

Все действия выполняются в одной асинхронной функции `main()`, которую
мы запускаем через `asyncio.run(main())`. Это позволяет избежать
проблем с повторным использованием event loop в интерактивной среде.

Порядок заданий:
1) Пагинация (5.1):
   1.1 LostItem, по 3 штуки на страницу — вывести первую и вторую страницу
   1.2 FoundItem, по 2 штуки на страницу — вывести вторую страницу
   1.3 LostItem, по 4 штуки на страницу — вывести последнюю страницу

2) Фильтрация (5.2):
   2.1 LostItem, у которых в локации встречается "Москва"
   2.2 FoundItem, только для категорий "Документы"(id=1) и "Украшения"(id=4)
   2.3 LostItem, потерянные за последние 10 дней

3) Сортировка (5.3):
   3.1 LostItem: сортировка по name (asc)
   3.2 FoundItem: сортировка по found_date (desc)
   3.3 LostItem: сортировка сначала по category_id (asc), потом lost_date (desc)

После каждого задания выводятся результаты, чтобы проверить, что всё работает правильно.
"""

import asyncio
import datetime
from sqlalchemy import select, func
from sqlalchemy import asc, desc

# Импортируем вашу фабрику сессий и модели:
from database import AsyncSessionLocal
import models


async def main():
    """
    Внутри одной корутины решаем все 9 заданий (по 3 для пагинации, фильтрации, сортировки).
    В конце закрываем сессию. Запуск: python test_db_tasks.py
    """

    # Создаём одну асинхронную сессию
    session = AsyncSessionLocal()

    # -------------------------
    # 5.1 ПАГИНАЦИЯ
    # -------------------------
    print("=== 5.1 ПАГИНАЦИЯ ===")

    # ЗАДАНИЕ 1:
    # LostItem: хотим по 3 штуки на страницу. Нужно вывести
    #   - первую страницу (skip=0, limit=3)
    #   - вторую страницу (skip=3, limit=3)
    print("\nЗАДАНИЕ 1) LostItem, по 3 штуки на страницу. Первая и вторая страница.")

    # Первая страница (skip=0, limit=3)
    ...

    # Вторая страница (skip=3, limit=3)
    ...

    # ЗАДАНИЕ 2:
    # FoundItem: по 2 штуки на страницу, нужно вывести вторую страницу
    # То есть skip=2, limit=2 (пропускаем первые 2, берём следующие 2).
    print("\nЗАДАНИЕ 2) FoundItem, по 2 штуки на страницу. Вывести вторую страницу.")

    ...

    # ЗАДАНИЕ 3:
    # LostItem: по 4 штуки на страницу, нужно вывести последнюю страницу.
    # Для этого:
    # - Считаем общее количество LostItem
    # - Находим общее число страниц
    # - Делаем skip для последней страницы
    print("\nЗАДАНИЕ 3) LostItem, по 4 штуки на страницу, вывести последнюю страницу.")

    ...

    # -------------------------
    # 5.2 ФИЛЬТРАЦИЯ
    # -------------------------
    print("\n=== 5.2 ФИЛЬТРАЦИЯ ===")

    # ЗАДАНИЕ 1:
    # LostItem, у которых в location встречается "Москва" (регистронезависимо)
    # Используем ilike('%Москва%')
    print("\nЗАДАНИЕ 1) LostItem, location ILIKE '%Москва%'")

    ...

    # ЗАДАНИЕ 2:
    # FoundItem, категория — только "Документы" и "Украшения".
    # Предположим, у них category_id=1 и category_id=4 (у вас может быть другое, проверяйте в БД).
    print("\nЗАДАНИЕ 2) FoundItem, category_id IN [1, 4]")

    ...

    # ЗАДАНИЕ 3:
    # LostItem, потерянные за последние 10 дней
    # То есть lost_date >= now() - 10
    print("\nЗАДАНИЕ 3) LostItem, потерянные за 10 дней (lost_date >= now()-10)")

    ...

    # -------------------------
    # 5.3 СОРТИРОВКА
    # -------------------------
    print("\n=== 5.3 СОРТИРОВКА ===")

    # ЗАДАНИЕ 1:
    # LostItem: сортировка по name (asc)
    # Вывести хотя бы первые 5
    print("\nЗАДАНИЕ 1) LostItem, сортировка name ASC (первые 5).")

    ...

    # ЗАДАНИЕ 2:
    # FoundItem: сортировка по found_date (desc),
    # чтобы самые последние/свежие были в начале.
    print("\nЗАДАНИЕ 2) FoundItem, сортировка по found_date DESC (первые 5).")

    ...

    # ЗАДАНИЕ 3:
    # LostItem: комбинированная сортировка:
    #   - сначала по category_id (asc)
    #   - затем по lost_date (desc)
    print("\nЗАДАНИЕ 3) LostItem, сначала category_id ASC, потом lost_date DESC.")

    ...

    # -------------------------
    # Закрываем сессию в самом конце
    # -------------------------
    await session.close()


if __name__ == "__main__":
    # Запускаем единожды: python test_db_tasks.py
    asyncio.run(main())
